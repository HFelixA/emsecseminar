\chapter{Theoretical Background}

\section{Notation}
As we will only work with ideal lattices in our paper, all operations will be done within the ring \(R_q=\mathbb{Z}_q[x]/(f(x))\) with \(f(x)\) being an irreducible polynomial of degree \(n\) and all coefficients being reduced modulo \(q\).

Polynomials will be written as bold lower case letters like \(\textbf{f}\). As we will use the \textit{\ac{NTT}} for efficient polynomial multiplication within a ring \(R_q\), polynomials in the \textit{\ac{NTT}} domain will be written as \(\tilde{\textbf{f}}\). Vectors will be denoted with an arrow on top of them (\(\vec{x}\)), while matrices will be denoted by bold upper case letters (\(\textbf{A}\)). The entries of a vector \(\vec{x}\) will be called \(x_i\), with \(i\) specifying the position within the vector starting at 0.

The notation for the \(l_p\) norm of a vector \(\vec{x}\) will be \(\|\vec{x}\|_p\), only with the exception of the \(l_2\) norm, which will be referred to as \(\|\vec{x}\|=\sqrt{\sum_{i} x_i^2}\).

\section{Ideal Lattices}
A lattice \(\Lambda\) is discrete subgroup of \(\mathbb{R}^n\) that is defined as a set of \(m \leq n\) linearly independent vectors \(\vec{b}_1,...,\vec{b}_m \in \mathbb{R}^n\) and is generated by all linear combinations of those \(\vec{b}_i\)'s with integer coefficients:
\begin{equation}
	\Lambda(\vec{b}_1,...,\vec{b}_m)=\left \{ \displaystyle \sum_{i=1}^{m} x_i \vec{b}_i \: \middle | \: x_i \in \mathbb{Z} \right \}
\end{equation}
The set \(\{\vec{b}_1,...,\vec{b}_m\}\) of those vectors is called the basis of that lattice, which commonly is represented by a matrix \(\textbf{B}=(\vec{b}_1,...,\vec{b}_m)\).

Furthermore, an ideal lattice is is lattice that corresponds to ideals in a ring \(R_q\). From this it follows that we can deal with polynomials instead of matrices, which makes arithmetics used for cryptographic applications much more efficient. In our paper we will confine ourselves to those ideal lattices, as most of the current work in that area focuses around them. For more on the topic of ideal lattices, see \cite{cryptoeprint:2012:230}.

\section{Ring Learning with Errors Problem}
The \acf{ring-LWE} has been introduced in \cite{cryptoeprint:2012:230} in 2012. There are two instances of the \ac{ring-LWE}, a search one and a decisional one. For both of them, we can state that there is a given \(\textbf{s} \in R_q\). Next, an error polynomial \(\textbf{e}_i \in R_q\) is sampled from the discrete Gaussian distribution \(\mathcal{N}_\mathbb{Z}^{n} (0, \sigma^2)\) and another polynomial \(\textbf{a}_i \in R_q\) is sampled uniformly at random. Finally, a polynomial \(\textbf{b}_i\) is computed as \(\textbf{b}_i = (\textbf{a}_i \cdot \textbf{s}) + \textbf{e}_i\).

For the \textit{search} \ac{ring-LWE} problem, one needs to find the unknown polynomial \(\textbf{s}\) for a given pair \((\textbf{a}_i, \textbf{b}_i)\). The \textit{decisional} \ac{ring-LWE} problem is about distinguishing between pairs \((\textbf{a}_i, \textbf{b}_i)\) that have actually been computed the way described before and pairs \((\textbf{a}_i, \textbf{b}_i)\) that have been sampled uniformly at random in \(R_q\).

\section{Discrete Gaussian Distribution}
The discrete Gaussian distribution with mean \(\mu\) and standard deviation \(\sigma\) is denoted as \(\mathcal{N}_\mathbb{Z} (\mu, \sigma^2)\). In this paper we will focus on zero-centered distributions \(\mathcal{N}_\mathbb{Z} (0, \sigma^2)\) with a density function \(\rho_\sigma(x)\) given by:
\begin{equation}
	\rho_\sigma(x)=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{x^2}{2\sigma^2}}
\end{equation}
The probability function of discrete Gaussian distribution over \(\mathbb{Z}\) is then defined as \(D_\sigma(x)=\rho_\sigma(x)/\rho_\sigma(\mathbb{Z})\) with \(\rho_\sigma(\mathbb{Z})=\sum_{y=-\infty}^{\infty} \rho_\sigma(y)\). As we will sample entire vectors most of the time, we denote the discrete Gaussian distribution over \(\mathbb{Z}^m\) as \(\mathcal{N}_\mathbb{Z}^{n} (\mu, \sigma^2)\) and its probability function as \(D_\sigma^m(\vec{x})=\rho_\sigma(\vec{x})/\rho_\sigma(\mathbb{Z})^m\) with \(\rho_\sigma(\vec{x})\) being defined as follows:
\begin{equation}
	\rho_\sigma(\vec{x})=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{\|\textbf{x}\|^2}{2\sigma^2}}
\end{equation}

\section{Cryptographic Algorithms}
This Section will give a short overview of two cryptographic algorithms, that are based on ideal lattices and the \ac{ring-LWE} problem. While the first algorithm can exclusively be used for encryption, the second one is a signature algorithm. For more information on the mathematical background of those algorithms, we would like to refer you to the cited papers.

\subsection{Ring-LWE Encryption Scheme}
In our paper we focus on the encryption scheme published in \cite{cryptoeprint:2012:230}, which will be referred to as \textit{\ac{LPR}}. This scheme consists of three main operations: \textit{Key Generation}, \textit{Encryption} and \textit{Decryption}. The globally known parameters of this scheme are \((n, q, \sigma)\) and a polynomial \(\textbf{g}\). The dimension of the polynomial ring \(R_q\) is defined by \(n\), while \(q\) is the modulus. The standard deviation of the discrete Gaussian distribution is given by \(\sigma\).

\textbf{Key Generation:} In this step, the coefficients of the two polynomials \(\textbf{r}\) and \(\textbf{s}\) are sampled according to the discrete Gaussian distribution \(\mathcal{N}_\mathbb{Z}^{n} (0, \sigma^2)\). Then the public key \(\textbf{p}\) is computed by \(\textbf{p} = \textbf{r} - \textbf{g} \cdot \textbf{s}\). The resulting output is a key pair \((\textbf{p}, \textbf{s})\) with \(\textbf{p}\) being the public key and \(\textbf{s}\) being the secret key.

\textbf{Encryption:} The encryption phase takes a \(n\)-bit message \(\textbf{m}\) and the public key \(\textbf{p}\) as input. Initially, the message \(\textbf{m}\) is encoded as an element of the ring \(R_q\) by multiplying each of its bits by \(q/2\) and is then denoted by \(\textbf{m}_{enc}\). In the following step, three error polynomials \(\textbf{e}_1\), \(\textbf{e}_2\) and \(\textbf{e}_3\) are sampled according to \(\mathcal{N}_\mathbb{Z}^{n} (0, \sigma^2)\) and will be used as noise. The ciphertext then consists of two parts \((\textbf{c}_1, \textbf{c}_2)\), with \(\textbf{c}_1 = \textbf{g} \cdot \textbf{e}_1 + \textbf{e}_2\) and \(\textbf{c}_2 = \textbf{p} \cdot \textbf{e}_1 + \textbf{e}_3 + \textbf{m}_{enc}\). The encryption algorithm returns the ciphertext \((\textbf{c}_1,\textbf{c}_2)\).

\textbf{Decryption:} For decryption, we start by computing \(\textbf{m}_{enc} = \textbf{c}_1 \cdot \textbf{s} + \textbf{c}_2\). To decode \(\textbf{m}_{enc}\), we need a function \(\textsc{Decode}(m_{enc,i})\) with \(m_{enc,i}\) being an element of \(\textbf{m}_{enc}\). One possible function is given below:
\begin{equation}
    \textsc{Decode}(x)=\begin{cases}
        0, & \text{if }x \in (0,q/4) \cup (3q/4,q)\\
        1, & \text{if }x \in (q/4,3q/4)
    \end{cases}
\end{equation}

\subsection{BLISS}
The \acf{BLISS} is a signature algorithm based on lattice cryptography that was proposed in \cite{bliss}. We will just provide the basic algorithms of the signature scheme, for the security proof and the motivation of the construction we would refer you to the original paper.
An example implementation can be found at \cite{Poeppelmann2014}.

\ac{BLISS} uses the following parameters: dimension \(n\), modulus \(q\) and standard deviation \(\sigma\). Furthermore, is makes use of a cryptographic hash function \(H\), which outputs a \(n\) bit binary vector with weight \(\kappa\). The density of the polynomials belonging to the secret key \(\textbf{S}\) is determined by the parameters \(d_1\) and \(d_2\) and \(d\) determines the length of the second signature component \(\textbf{z}_2^\dagger\).

\textbf{Key Generation:} The keys generated by Algorithm \ref{BLISSKeyGen} are correct due to the following equation:
\begin{equation}
    \textbf{a}_1 \cdot \textbf{s}_1 + \textbf{a}_2 \cdot \textbf{s}_2 = 2 \textbf{a}_q \cdot \textbf{f} + (q - 2) \cdot (2 \textbf{g} + 1) \equiv 2 (2 \textbf{g} + 1) + (q - 2) (2 \textbf{g} + 1) \equiv q \; mod \; 2q
\end{equation}

An attacker might validate a candidate for \(\textbf{s}_1 = \textbf{f}\) by verifying the distributions of \(\textbf{f}\), \(\textbf{a}_q \cdot \textbf{f} \equiv 2 \textbf{g} + 1\) mod \(2q\) and \(\textbf{a}_1 \cdot \textbf{f} + \textbf{a}_2 \cdot (\textbf{a}_q \cdot \textbf{f}) \equiv q\) mod \(2q\).

\begin{algorithm}
    \label{BLISSKeyGen}
    \caption{\textsc{BLISS Key Generation}}
    \begin{algorithmic}[1]
        \Ensure{BLISS key pair \((\textbf{A},\textbf{S})\) with public key \(\textbf{A}=(\textbf{a}_1,\textbf{a}_2) \in R^2_{2q}\) and secret key \(\textbf{S}=(\textbf{s}_1,\textbf{s}_2) \in R^2_{2q}\), such that \(\textbf{AS}=\textbf{a}_1 \cdot \textbf{s}_1 + \textbf{a}_2 \cdot \textbf{s}_2 \equiv q\) mod \(2q\)}
        \State{Choose \(\textbf{f},\textbf{g} \in R_{2q}\) uniformly at random with exactly \(d_1\) entries in \(\{\pm 1\}\) and \(d_1\)
entries in \(\{\pm 2\}\)}
		\State{\(\textbf{S}=(\textbf{s}_1,\textbf{s}_2)=(\textbf{f},2\textbf{g}+1)\)}
		\If{\(\textbf{f}\) violates certain conditions (see \cite{bliss})}
			\State{Restart}
		\EndIf
		\State{\(\textbf{a}_q=(2\textbf{g}+1)/\textbf{f}\) mod \(q\) (restart if \textbf{f} is not invertible)}\\
		\Return{\((\textbf{A},\textbf{S})\) with \(\textbf{A}=(2\textbf{a}_q,q-2)\) mod \(2q\)}
    \end{algorithmic}
\end{algorithm}

\textbf{Signature Generation:} The signature algorithm given in Algo. \ref{BLISSSig} uses the parameters \(p = \lfloor 2q/2^d \rfloor\) (the \(d\) highest order bits of \(2q\)) and a constant \(\zeta = (q-2)^{-1}\) mod \(2q\). In the following, the \(d\) highest order bits of a value \(x\) will be denoted as \(\lfloor x \rceil _d\).
\begin{algorithm}
    \label{BLISSSig}
    \caption{\textsc{BLISS Signature Algorithm}}
    \begin{algorithmic}[1]
    	\Require{Message \(\mu\), public key \(\textbf{A}=(\textbf{a}_1,q-2)\), secret key \(\textbf{S}=(\textbf{s}_1,\textbf{s}_2)\)}
        \Ensure{Signature \((\textbf{z}_1,\textbf{z}_2^\dagger,\textbf{c}) \in \mathbb{Z}^n_{2q} \times \mathbb{Z}^n_p \times \{0,1\}^n\)}
        \State{\(\textbf{y}_1,\textbf{y}_2 \leftarrow \mathcal{N}_\mathbb{Z}^{n} (0, \sigma^2)\)}
        \State{\(\textbf{u}=\zeta \cdot \textbf{a}_1 \cdot \textbf{y}_1 + \textbf{y}_2\) mod \(2q\)}
        \State{\(\textbf{c}=H(\lfloor \textbf{u} \rceil_d)\) mod \(p\), \(\mu\)}
        \State{Choose a random bit \(b\)}
        \State{\(\textbf{z}_1=\textbf{y}_1+(-1)^b\textbf{s}_1 \cdot \textbf{c}\) mod \(2q\)}
        \State{\(\textbf{z}_2=\textbf{y}_2+(-1)^b\textbf{s}_2 \cdot \textbf{c}\) mod \(2q\)}
        \State{Continue with a probability based on \(\sigma\), \(\|\textbf{Sc}\|\), \(\langle \textbf{z},\textbf{Sc} \rangle\) (see \cite{bliss}), else restart}
        \State{\(\textbf{z}_2^\dagger=(\lfloor \textbf{u} \rceil_d-\lfloor \textbf{u}-\textbf{z}_2 \rceil_d)\) mod \(p\)}\\
        \Return{\((\textbf{z}_1, \textbf{z}_2^\dagger, \textbf{c})\)}
    \end{algorithmic}
\end{algorithm}

\textbf{Signature Verification:} Algorithm \ref{BLISSVer} shows the signature verification. We want to stress that reductions modulo \(2q\) are done before reductions modulo \(p\).
\begin{algorithm}
    \label{BLISSVer}
    \caption{\textsc{BLISS Verification Algorithm}}
    \begin{algorithmic}[1]
    	\Require{Message \(\mu\), public key \(\textbf{A}=(\textbf{a}_1,q-2)\), signature \((\textbf{z}_1, \textbf{z}_2^\dagger, \textbf{c})\)}
    	\If{\(\textbf{z}_1,\textbf{z}_2^\dagger\) violate certain conditions (see \cite{bliss})}
    		\State{Reject}
    	\EndIf
    	\If{\(\textbf{c}=H(\lfloor \zeta \cdot \textbf{a}_1 \cdot \textbf{z}_1 + \zeta \cdot q \cdot \textbf{c} \rceil_d + \textbf{z}_2^\dagger\) mod \(p\), \(\mu\))}
    		\State{Accept}
    	\EndIf
    \end{algorithmic}
\end{algorithm}

\section{Side-Channel Attack Terminology}
Side-channel attacks use leaked information from physical implementations of cryptographic algorithms to conclude secret information like encryption keys. Such leakage could e.g. be the power consumption during cryptographic operations. One type of attacks that makes use of leakages through power consumption is \textit{\ac{DPA}}. When describing \ac{DPA} we use a notation commonly employed in research, like in \cite{cryptoeprint:2010:646}, \cite{cryptoeprint:2010:385}, \cite{DBLP:conf/crypto/KocherJJ99} and \cite{Kocher2011}, where \acl{DPA} has been introduced.

To perform a DPA, one needs to correlate a leakage with a prediction made on a special value that depends on both, the secret key and the plaintext. Such a value is called a \textit{sensitive variable}. A common countermeasure to \textit{\ac{DPA}} is masking, where sensitives variables are randomly split into \(d\) shares. A masking approach with \(d\) shares is referred to as a \((d-1)\)-th order masking, as \(d-1\) shares are picked randomly and the last share is computed in a way, that the combination of all \(d\) shares equals the shared sensitive variable. To defeat this kind of countermeasures, the class of \textit{\ac{HO-DPA}} has been introduced. To overcome \((d-1)\)-th order masking, \(d\)-th order \textit{\ac{DPA}} is needed, which can be done by combining the leakage of \(d\) different signals that correspond to the \(d\) shares of the sensitive variable. Theoretically, higher order masking can always be defeated by HO-DPA. However, the difficulty of \textit{\ac{HO-DPA}} is growing exponentially due to noise effects. In practice, first order masking is most commonly used, thus there is a big focus on second order \textit{\ac{DPA}} in research.
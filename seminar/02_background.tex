%
% Sample conclusion of your thesis
%

\chapter{Theoretical Background}

\section{Notation}
As we will only work with ideal lattices in our paper, all operations will be done within the ring \(R_q=\mathbb{Z}_q[x]/(f(x))\) with \(f(x)\) being an irreducible polynomial of degree \(n\) and all coefficients being reduced modulo \(q\).\\
Polynomials will be written as \(f(x)\) and vectors will be denoted by bold lower case letters, while matrices will be denoted by bold upper case letters. The entries of a vector \(\textbf{x}\) will be called \(x_i\), with \(i\) specifying the position within the vector starting at 0.\\
The notation for the \(l_p\) norm of a vector \(\textbf{x}\) will be \(\|x\|_p\), only with the exception of the \(l_2\) norm, which will be referred to as \(\|x\|=\sqrt{\sum_{i} x_i^2}\).

\section{Ideal Lattices}
A lattice \(\Lambda\) is discrete subgroup of \(\mathbb{R}^n\) that is defined as a set of \(m \leq n\) linearly independent vectors \(\textbf{b}_1,...,\textbf{b}_m \in \mathbb{R}^n\) and is generated by all linear combinations of those \(\textbf{b}_i\)'s with integer coefficients:
\begin{center}
	\(\Lambda(\textbf{b}_1,...,\textbf{b}_m)=\left \{ \displaystyle \sum_{i=1}^{m} x_i \textbf{b}_i \: \middle | \: x_i \in \mathbb{Z} \right \}\)
\end{center}
The set \(\{\textbf{b}_1,...,\textbf{b}_m\}\) of those vectors is called the basis of that lattice. Such a basis is commonly represented by a matrix \(\textbf{B}=(\textbf{b}_1,...,\textbf{b}_m)\).\\
Furthermore, an ideal lattice is is lattice that corresponds to ideals in a ring \(R_q\). This basically means, that we can deal with polynomials instead of matrices, which makes arithmetics used for cryptographic applications much more efficient. In our paper we will confine ourselves to those ideal lattices, as most of the current work in that area focuses around them. For more on the topic of ideal lattices, see \cite{cryptoeprint:2012:230}.

\section{Learning with Errors Problem}

\section{Discrete Gaussian Distribution}
The discrete Gaussian distribution with mean \(\mu\) and standard deviation \(\sigma\) is denoted as \(\mathcal{N}_\mathbb{Z} (\mu, \sigma^2)\). In this paper we will focus on zero-centered distributions \(\mathcal{N}_\mathbb{Z} (0, \sigma^2)\) with a density function \(\rho_\sigma(x)\) given by:
\begin{center}
	\(\rho_\sigma(x)=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\)
\end{center}
The discrete Gaussian distribution over \(\mathbb{Z}\) is then defined as \(D_\sigma(x)=\rho_\sigma(x)/\rho_\sigma(\mathbb{Z})\) with \(\rho_\sigma(\mathbb{Z})=\sum_{y=-\infty}^{\infty} \rho_\sigma(y)\). As we will sample whole vectors most of the time, we define the discrete Gaussian distribution over \(\mathbb{Z}^m\) as \(D_\sigma^m(x)=\rho_\sigma(\textbf{x})/\rho_\sigma(\mathbb{Z})^m\) with \(\rho_\sigma(\textbf{x})\) defined as follows:
\begin{center}
	\(\rho_\sigma(\textbf{x})=\frac{1}{\sqrt{2\pi \sigma^2}}e^{-\frac{\|\textbf{x}\|^2}{2\sigma^2}}\)
\end{center}
\section{Cryptographic Algorithms}

\subsection{Ring-LWE Encryption Scheme}

\subsection{BLISS Signature Scheme}
\begin{algorithm}
    \caption{\textsc{BLISS Key Generation}}
    \begin{algorithmic}[1]
        \Ensure{BLISS key pair \((\textbf{A},\textbf{S})\) with public key \(\textbf{A}=(\textbf{a}_1,\textbf{a}_2) \in R^2_{2q}\) and secret key \(\textbf{S}=(\textbf{s}_1,\textbf{s}_2) \in R^2_{2q}\), such that \(\textbf{AS}=\textbf{a}_1 \cdot \textbf{s}_1 + \textbf{a}_2 \cdot \textbf{s}_2 \equiv q\) mod \(2q\)}
        \State{Choose \(\textbf{f},\textbf{g} \in R_{2q}\) uniformly at random with exactly \(d_1\) entries in \(\{\pm 1\}\) and \(d_1\)
entries in \(\{\pm 2\}\)}
		\State{\(\textbf{S}=(\textbf{s}_1,\textbf{s}_2)=(\textbf{f},2\textbf{g}+1)\)}
		\If{\(\textbf{f}\) violates certain conditions (see \cite{bliss})}
			\State{Restart}
		\EndIf
		\State{\(\textbf{a}_q=(2\textbf{g}+1)/\textbf{f}\) mod \(q\) (restart if \textbf{f} is not invertible)}\\
		\Return{\((\textbf{A},\textbf{S})\) with \(\textbf{A}=(2\textbf{a}_q,q-2)\) mod \(2q\)}
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{\textsc{BLISS Signature Algorithm}}
    \begin{algorithmic}[1]
    	\Require{Message \(\mu\), public key \(\textbf{A}=(\textbf{a}_1,q-2)\), secret key \(\textbf{S}=(\textbf{s}_1,\textbf{s}_2)\)}
        \Ensure{Signature \((\textbf{z}_1,\textbf{z}_2^\dagger,\textbf{c}) \in \mathbb{Z}^n_{2q} \times \mathbb{Z}^n_p \times \{0,1\}^n\)}
        \State{\(\textbf{y}_1,\textbf{y}_2 \leftarrow D_\sigma^n\)}
        \State{\(\textbf{u}=\zeta \cdot \textbf{a}_1 \cdot \textbf{y}_1 + \textbf{y}_2\) mod \(2q\)}
        \State{\(\textbf{c}=H(\lfloor \textbf{u} \rceil_d)\) mod \(p\), \(\mu\)}
        \State{Choose a random bit \(b\)}
        \State{\(\textbf{z}_1=\textbf{y}_1+(-1)^b\textbf{s}_1 \cdot \textbf{c}\) mod \(2q\)}
        \State{\(\textbf{z}_2=\textbf{y}_2+(-1)^b\textbf{s}_2 \cdot \textbf{c}\) mod \(2q\)}
        \State{Continue with a probability based on \(\sigma\), \(\|\textbf{Sc}\|\), \(\langle \textbf{z},\textbf{Sc} \rangle\) (see \cite{bliss}), else restart}
        \State{\(\textbf{z}_2^\dagger=(\lfloor \textbf{u} \rceil_d-\lfloor \textbf{u}-\textbf{z}_2 \rceil_d)\) mod \(p\)}\\
        \Return{\((\textbf{z}_1, \textbf{z}_2^\dagger, \textbf{c})\)}
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{\textsc{BLISS Verification Algorithm}}
    \begin{algorithmic}[1]
    	\Require{Message \(\mu\), public key \(\textbf{A}=(\textbf{a}_1,q-2)\), signature \((\textbf{z}_1, \textbf{z}_2^\dagger, \textbf{c})\)}
    	\If{\(\textbf{z}_1,\textbf{z}_2^\dagger\) violate certain conditions (see \cite{bliss})}
    		\State{Reject}
    	\EndIf
    	\If{\(\textbf{c}=H(\lfloor \zeta \cdot \textbf{a}_1 \cdot \textbf{z}_1 + \zeta \cdot q \cdot \textbf{c} \rceil_d + \textbf{z}_2^\dagger\) mod \(p\), \(\mu\))}
    		\State{Accept}
    	\EndIf
    \end{algorithmic}
\end{algorithm}

\section{Side-Channel Attack Terminology}